## lab5
1. Скрипт rmtrash
a. Скрипту передается один параметр – имя файла в текущем каталоге вызова скрипта.
b. Скрипт проверяет, создан ли скрытый каталог trash в домашнем каталоге пользователя. Если он не создан – создает его.
c. После этого скрипт создает в этом каталоге жесткую ссылку на переданный файл с уникальным именем (например, присваивает каждой новой ссылке имя, соответствующее следующему натуральному числу) и удаляет файл в текущем каталоге.
d. Затем в скрытый файл trash.log в домашнем каталоге пользователя помещается запись, содержащая полный исходный путь к удаленному файлу и имя созданной жесткой ссылки.
2. Скрипт untrash
a. Скрипту передается один параметр – имя файла, который нужно восстановить (без полного пути – только имя).
b. Скрипт по файлу trash.log должен найти все записи, содержащие в качестве имени файла переданный параметр, и выводить по одному на экран полные имена таких файлов с запросом подтверждения.
c. Если пользователь отвечает на подтверждение положительно, то предпринимается попытка восстановить файл по указанному полному пути (создать в соответствующем каталоге жесткую ссылку на файл из trash и удалить соответствующий файл из trash). Если каталога, указанного в полном пути к файлу, уже не существует, то файл восстанавливается в домашний каталог пользователя с выводом соответствующего сообщения.
3. Скрипт backup
a. Скрипт создаст в /home/user/ каталог с именем Backup-YYYY-MM-DD, где YYYY-MM-DD дата запуска скрипта, если в /home/user/ нет каталога с именем, соответствующим дате, отстоящей от текущей менее чем на 7 дней. Если в /home/user/ уже есть «действующий» каталог резервного копирования (созданный не ранее 7 дней от даты запуска скрипта), то новый каталог не создается. Для определения текущей даты можно воспользоваться командой date.
b. Если новый каталог был создан, то скрипт скопирует в этот каталог все файлы из каталога /home/user/source/ (для тестирования скрипта создайте такую директорию и набор файлов в ней). После этого скрипт выведет в режиме дополнения в файл /home/user/backup-report следующую информацию: строка со сведениями о создании нового каталога с резервными копиями с указанием его имени и даты создания; список файлов из /home/user/source/, которые были скопированы в этот каталог.
c. Если каталог не был создан (есть «действующий» каталог резервного копирования), то скрипт должен скопировать в него все файлы из /home/user/source/ по следующим правилам: если файла с таким именем в каталоге резервного копирования нет, то он копируется из /home/user/source. Если файл с таким именем есть, то его размер сравнивается с размером одноименного файла в действующем каталоге резервного копирования. Если размеры совпадают, файл не копируется. Если размеры отличаются, то файл копируется c автоматическим созданием версионной копии, таким образом, в действующем каталоге резервного копирования появляются обе версии файла (уже имеющийся файл переименовывается путем добавления дополнительного расширения «.YYYY-MM-DD» (дата запуска скрипта), а скопированный сохраняет имя). После окончания копирования в файл /home/user/backup-report выводится строка о внесении изменений в действующий каталог резервного копирования с указанием его имени и даты внесения изменений, затем строки, содержащие имена добавленных файлов с новыми именами, а затем строки с именами добавленных файлов с существовавшими в действующем каталоге резервного копирования именами с указанием через пробел нового имени, присвоенного предыдущей версии этого файла.
4. Скрипт upback
a. Скрипт должен скопировать в каталог /home/user/restore/ все файлы из актуального на данный момент каталога резервного копирования (имеющего в имени наиболее свежую дату), за исключением файлов с предыдущими версиями.

## lab4
1. Создайте и однократно выполните скрипт (в этом скрипте нельзя использовать условный оператор и операторы проверки свойств и значений), который будет пытаться создать директорию test в домашней директории. Если создание директории пройдет успешно, скрипт выведет в файл ~/report сообщение вида "catalog test was created successfully" и создаст в директории test файл с именем Дата_Время_Запуска_Скрипта. Затем независимо от результатов предыдущего шага скрипт должен опросить с помощью команды ping хост www.net_nikogo.ru и, если этот хост недоступен, дописать сообщение об ошибке в файл ~/report.
2. Задайте еще один однократный запуск скрипта из пункта 1 через 2 минуты. Организуйте слежение за файлом ~/report и выведите на консоль новые строки из этого файла, как только они появятся.
3. Задайте запуск скрипта из пункта 1 каждые 5 минут каждого часа в день недели, в который вы будете выполнять работу.
4. Создайте два фоновых процесса, выполняющих одинаковый бесконечный цикл вычисления (например, перемножение двух чисел). После запуска процессов должна сохраниться возможность использовать виртуальные консоли, с которых их запустили. Используя команду top, проанализируйте процент использования ресурсов процессора этими процессами. Добейтесь, чтобы тот процесс, который был запущен первым, использовал ресурс процессора не более чем на 20%.
5. Процесс «Генератор» передает информацию процессу «Обработчик» с помощью файла. Процесс «Обработчик» должен осуществлять следующую обработку новых строк в этом файле: если строка содержит единственный символ «+», то процесс обработчик переключает режим на «сложение» и ждет ввода численных данных. Если строка содержит единственный символ «*», то обработчик переключает режим на «умножение» и ждет ввода численных данных. Если строка содержит целое число, то обработчик осуществляет текущую активную операцию (выбранный режим) над текущим значением вычисляемой переменной и считанным значением (например, складывает или перемножает результат предыдущего вычисления со считанным числом). При запуске скрипта режим устанавливается в «сложение», а вычисляемая переменная приравнивается к 1. В случае получения строки QUIT скрипт выдает сообщение о плановой остановке и завершает работу. В случае получения любых других значений строки скрипт завершает работу с сообщением об ошибке входных данных.
6. Процесс «Генератор» считывает строки с консоли, пока ему на вход не поступит строка TERM. В этом случае он посылает системный сигнал SIGTERM процессу обработчику. Процесс «Обработчик» (как и в примере, выводящий в бесконечном цикле натуральное число каждую секунду) должен перехватить системный сигнал SIGTERM и завершить работу, предварительно выведя сообщение о завершении работы по сигналу от другого процесса.
7. Процесс «Генератор» считывает с консоли строки в бесконечном цикле. Если считанная строка содержит единственный символ «+», он посылает процессу «Обработчик» сигнал USR1. Если строка содержит единственный символ «*», генератор посылает обработчику сигнал USR2. Если строка содержит слово TERM, генератор посылает обработчику сигнал SIGTERM. Другие значения входных строк игнорируются. Обработчик добавляет 2 или умножает на 2 текущее значение обрабатываемого числа (начальное значение принять на единицу) в зависимости от полученного пользовательского сигнала и выводит результат на экран. Вычисление и вывод производятся один раз в секунду. Получив сигнал SIGTERM, «Обработчик» завершает свою работу, выведя сообщения о завершении работы по сигналу от другого процесса.

## lab3
1. Посчитать количество процессов, запущенных пользователем user, и вывести в файл пары PID:команда для таких процессов.
2. Вывести на экран PID процесса, запущенного последним (с последним временем запуска).
3. Вывести в файл список PID всех процессов, которые были запущены командами, расположенными в /sbin/
4. Для каждого процесса посчитать разность резидентной и разделяемой части памяти процесса (в страницах). Вывести в файл строки вида PID:разность, отсортированные по убыванию этой разности.
5. Для всех зарегистрированных в данный момент в системе процессов выведите в один файл строки ProcessID=PID : Parent_ProcessID=PPID : Average_Sleeping_Time=SleepAVG. Значения PPid и Pid возьмите из файлов status, значение SleepAVG из файла sched поле avg_atom, которые находятся в директориях с названиями, соответствующими PID процессов в /proc . Отсортируйте эти строки по идентификаторам родительских процессов.
6. В полученном на предыдущем шаге файле после каждой группы записей с одинаковым идентификатором родительского процесса вставить строку вида Average_Sleeping_Children_of_ParentID=N is M, где N = PPID, а M – среднее, посчитанное из SleepAVG для данного процесса.


## lab2

1. Создать файл errors.log, в который поместить все строки из всех доступных для чтения файлов директории /var/log/, начинающиеся c последовательности символов ACPI, без указания имени файла, в котором встретилась строка. Вывести на экран те строчки из получившегося файла, которые содержат полные имена каких-либо файлов.
2. Создать full.log, в который вывести строки файла /var/log/Xorg.0.log, содержащие предупреждения и информационные сообщения, заменив маркеры предупреждений и информационных сообщений на слова Warning: и Information:, чтобы в получившемся файле сначала шли все ошибки, а потом все предупреждения. Вывести этот файл на экран.
3. Создать файл emails.lst, в который вывести через запятую все адреса электронной почты, встречающиеся во всех файлах директории /etc.
4. Найти в директории /bin все файлы, которые являются сценариями, и вывести на экран полное имя файла с интерпретатором, наиболее часто используемым в этих сценариях (только полное имя файла).
5. Вывести список пользователей системы с указанием их UID, отсортировав по UID. Сведения о пользователей хранятся в файле /etc/passwd. В каждой строке этого файла первое поле – имя пользователя, третье поле – UID. Разделитель – двоеточие.
6. Подсчитать общее количество строк в файлах, находящихся в директории /var/log/ и имеющих расширение log.
7. Вывести три наиболее часто встречающихся слова из man по команде bash длиной не менее четырех символов

## lab1
1. В параметрах скрипта передаются две строки. Вывести сообщение о равенстве или неравенстве переданных строк.
2. В параметрах при запуске скрипта передаются три целых числа. Вывести максимальное из них.
3. Считывать строки с клавиатуры, пока не будет введена строка "q". После этого вывести последовательность считанных строк в виде одной строки.
4. Считывать с клавиатуры целые числа, пока не будет введено четное число. После этого вывести количество считанных чисел.
5. Создать текстовое меню с четырьмя пунктами. При вводе пользователем номера пункта меню происходит запуск редактора nano, редактора vi, браузера links или выход из меню.
6. Если скрипт запущен из домашнего директория, вывести на экран путь к домашнему директорию и выйти с кодом 0. В противном случае вывести сообщение об ошибке и выйти с кодом 1.